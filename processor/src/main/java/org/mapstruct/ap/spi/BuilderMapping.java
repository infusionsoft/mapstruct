/**
 *  Copyright 2012-2017 Gunnar Morling (http://www.gunnarmorling.de/)
 *  and/or other contributors as indicated by the @authors tag. See the
 *  copyright.txt file in the distribution for a full listing of all
 *  contributors.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.mapstruct.ap.spi;

import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;

/**
 * Information about how to construct immutable instances using a builder.  Generated by
 * {@link org.mapstruct.ap.spi.BuilderProvider}
 */
public class BuilderMapping {
    private final TypeMirror finalType;
    private final TypeMirror builderType;
    private final ExecutableElement builderCreationMethod;
    private final ExecutableElement finalizeMethod;

    private BuilderMapping(TypeMirror finalType, TypeMirror builderType,
                           ExecutableElement builderCreationMethod,
                           ExecutableElement finalizeMethod) {
        assert finalType != null : "Target type must not be null";
        assert builderType != null : "Builder type must not be null";
        assert finalizeMethod != null : "Build method must not be null";
        this.builderType = builderType;
        this.finalType = finalType;
        this.builderCreationMethod = builderCreationMethod;
        this.finalizeMethod = finalizeMethod;
    }

    public TypeMirror getFinalType() {
        return finalType;
    }

    public TypeMirror getBuilderType() {
        return builderType;
    }

    public ExecutableElement getBuilderCreationMethod() {
        return builderCreationMethod;
    }

    public ExecutableElement getFinalizeMethod() {
        return finalizeMethod;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private TypeMirror targetType;
        private TypeMirror builderType;
        private ExecutableElement builderCreationMethod;
        private ExecutableElement buildMethod;

        public Builder targetType(TypeElement targetType) {
            this.targetType = targetType.asType();
            return this;
        }

        public Builder builderType(TypeElement builderType) {
            this.builderType = builderType.asType();
            return this;
        }

        public Builder targetType(TypeMirror targetType) {
            this.targetType = targetType;
            return this;
        }

        public Builder builderType(TypeMirror builderType) {
            this.builderType = builderType;
            return this;
        }

        public Builder builderCreationMethod(ExecutableElement builderCreationMethod) {
            this.builderCreationMethod = builderCreationMethod;
            return this;
        }

        public Builder buildMethod(ExecutableElement buildMethod) {
            this.buildMethod = buildMethod;
            return this;
        }

        public TypeMirror targetType() {
            return targetType;
        }

        public TypeMirror builderType() {
            return builderType;
        }

        public ExecutableElement buildMethod() {
            return this.buildMethod;
        }

        public ExecutableElement builderCreationMethod() {
            return builderCreationMethod;
        }

        public Builder merge(Builder... moreOptions) {
            for ( Builder builder : moreOptions ) {
                this.buildMethod = firstNonNull( builder.buildMethod, this.buildMethod );
                this.builderCreationMethod = firstNonNull( builder.builderCreationMethod, this.builderCreationMethod );
                this.builderType = firstNonNull( builder.builderType, this.builderType );
                this.targetType = firstNonNull( builder.targetType, this.targetType );
            }

            return this;
        }

        public BuilderMapping build() {
            return new BuilderMapping( targetType, builderType, builderCreationMethod, buildMethod );
        }
    }

    private static <X> X firstNonNull(X... items) {
        for ( X x : items ) {
            if ( x != null ) {
                return x;
            }
        }
        return null;
    }
}
